[
  {
    "instruction": "对源IP=192.168.0.1的数据包实现5%的随机丢包",
    "input": "",
    "output": "include <core.p4>\n#if __TARGET_TOFINO__ == 2\n#include <t2na.p4>\n#else\n#include <tna.p4>\n#endif\n\n#include \"common/headers.p4\"\n#include \"common/util.p4\"\n// 定义数据包头部\nheader ethernet_t {\n    bit<48> dstAddr;\n    bit<48> srcAddr;\n    bit<16> etherType;\n}\n\nheader ipv4_t {\n    bit<4>  version;\n    bit<4>  ihl;\n    bit<8>  diffserv;\n    bit<16> totalLen;\n    bit<16> identification;\n    bit<3>  flags;\n    bit<13> fragOffset;\n    bit<8>  ttl;\n    bit<8>  protocol;\n    bit<16> hdrChecksum;\n    bit<32> srcAddr;\n    bit<32> dstAddr;\n}\n\n// 定义元数据\nstruct metadata_t { }\n\n// 定义解析后的数据包头\nstruct headers_t {\n    ethernet_t ethernet;\n    ipv4_t ipv4;\n}\n\n// 定义标准元数据\nstruct standard_metadata_t;\n\n// 定义包解析器\nparser MyParser(\n    packet_in pkt,\n    out headers_t hdr,\n    inout metadata_t meta,\n    inout standard_metadata_t standard_metadata\n) {\n    state start {\n        pkt.extract(hdr.ethernet);\n        transition select(hdr.ethernet.etherType) {\n            0x0800: parse_ipv4; // IPv4\n            default: accept;\n        }\n    }\n    state parse_ipv4 {\n        pkt.extract(hdr.ipv4);\n        transition accept;\n    }\n}\n\n// 定义转发逻辑\ncontrol ingress(\n    inout headers_t hdr,\n    inout metadata_t meta,\n    inout standard_metadata_t standard_metadata\n) {\n    action drop() {\n        standard_metadata.egress_spec = 0; // 丢弃包\n    }\n\n    apply {\n        if (hdr.ipv4.isValid() && hdr.ipv4.srcAddr == 0xC0A80001) { // 192.168.0.1\n            // 模拟随机丢包\n            if (random() % 100 < 5) { // 5%的概率\n                drop();\n            }\n        }\n    }\n}\n\n// 定义包转发逻辑\ncontrol egress(\n    inout headers_t hdr,\n    inout metadata_t meta,\n    inout standard_metadata_t standard_metadata\n) {\n    apply { }\n}\n\n// 定义包出站逻辑\ncontrol MyDeparser(\n    packet_out pkt,\n    in headers_t hdr\n) {\n    apply {\n        pkt.emit(hdr.ethernet);\n        pkt.emit(hdr.ipv4);\n    }\n}\n\nPipeline(SwitchIngressParser(),\n         SwitchIngress(),\n         SwitchIngressDeparser(),\n         SwitchEgressParser(),\n         SwitchEgress(),\n         SwitchEgressDeparser()) pipe;\n\nSwitch(pipe) main;\n"
  },
  {
    "instruction": "对目的IP=192.168.0.1的数据包，修改其源IP=192.168.1.1",
    "input": "",
    "output": "include <core.p4>\n#if __TARGET_TOFINO__ == 2\n#include <t2na.p4>\n#else\n#include <tna.p4>\n#endif\n\n#include \"common/headers.p4\"\n#include \"common/util.p4\"\n// 定义数据包头部\nheader ethernet_t {\n    bit<48> dstAddr;\n    bit<48> srcAddr;\n    bit<16> etherType;\n}\n\nheader ipv4_t {\n    bit<4>  version;\n    bit<4>  ihl;\n    bit<8>  diffserv;\n    bit<16> totalLen;\n    bit<16> identification;\n    bit<3>  flags;\n    bit<13> fragOffset;\n    bit<8>  ttl;\n    bit<8>  protocol;\n    bit<16> hdrChecksum;\n    bit<32> srcAddr;\n    bit<32> dstAddr;\n}\n\n// 定义元数据\nstruct metadata_t { }\n\n// 定义解析后的数据包头\nstruct headers_t {\n    ethernet_t ethernet;\n    ipv4_t ipv4;\n}\n\n// 定义标准元数据\nstruct standard_metadata_t;\n\n// 定义包解析器\nparser MyParser(\n    packet_in pkt,\n    out headers_t hdr,\n    inout metadata_t meta,\n    inout standard_metadata_t standard_metadata\n) {\n    state start {\n        pkt.extract(hdr.ethernet);\n        transition select(hdr.ethernet.etherType) {\n            0x0800: parse_ipv4; // IPv4\n            default: accept;\n        }\n    }\n    state parse_ipv4 {\n        pkt.extract(hdr.ipv4);\n        transition accept;\n    }\n}\n\n// 定义转发逻辑\ncontrol ingress(\n    inout headers_t hdr,\n    inout metadata_t meta,\n    inout standard_metadata_t standard_metadata\n) {\n    apply {\n        if (hdr.ipv4.isValid() && hdr.ipv4.dstAddr == 0xC0A80001) { // 192.168.0.1\n            hdr.ipv4.srcAddr = 0xC0A80101; // 修改源IP为192.168.1.1\n        }\n    }\n}\n\n// 定义包转发逻辑\ncontrol egress(\n    inout headers_t hdr,\n    inout metadata_t meta,\n    inout standard_metadata_t standard_metadata\n) {\n    apply { }\n}\n\n// 定义包出站逻辑\ncontrol MyDeparser(\n    packet_out pkt,\n    in headers_t hdr\n) {\n    apply {\n        pkt.emit(hdr.ethernet);\n        pkt.emit(hdr.ipv4);\n    }\n}\n\nPipeline(SwitchIngressParser(),\n         SwitchIngress(),\n         SwitchIngressDeparser(),\n         SwitchEgressParser(),\n         SwitchEgress(),\n         SwitchEgressDeparser()) pipe;\n\nSwitch(pipe) main;\n"
  },
  {
    "instruction": "对目的IP=192.168.1.1的数据包，转发到CPU端口",
    "input": "",
    "output": "include <core.p4>\n#if __TARGET_TOFINO__ == 2\n#include <t2na.p4>\n#else\n#include <tna.p4>\n#endif\n\n#include \"common/headers.p4\"\n#include \"common/util.p4\"\n// 定义数据包头部\nheader ethernet_t {\n    bit<48> dstAddr;\n    bit<48> srcAddr;\n    bit<16> etherType;\n}\n\nheader ipv4_t {\n    bit<4>  version;\n    bit<4>  ihl;\n    bit<8>  diffserv;\n    bit<16> totalLen;\n    bit<16> identification;\n    bit<3>  flags;\n    bit<13> fragOffset;\n    bit<8>  ttl;\n    bit<8>  protocol;\n    bit<16> hdrChecksum;\n    bit<32> srcAddr;\n    bit<32> dstAddr;\n}\n\n// 定义元数据\nstruct metadata_t { }\n\n// 定义解析后的数据包头\nstruct headers_t {\n    ethernet_t ethernet;\n    ipv4_t ipv4;\n}\n\n// 定义标准元数据\nstruct standard_metadata_t;\n\n// 定义包解析器\nparser MyParser(\n    packet_in pkt,\n    out headers_t hdr,\n    inout metadata_t meta,\n    inout standard_metadata_t standard_metadata\n) {\n    state start {\n        pkt.extract(hdr.ethernet);\n        transition select(hdr.ethernet.etherType) {\n            0x0800: parse_ipv4; // IPv4\n            default: accept;\n        }\n    }\n    state parse_ipv4 {\n        pkt.extract(hdr.ipv4);\n        transition accept;\n    }\n}\n\n// 定义转发逻辑\ncontrol ingress(\n    inout headers_t hdr,\n    inout metadata_t meta,\n    inout standard_metadata_t standard_metadata\n) {\n    apply {\n        if (hdr.ipv4.isValid() && hdr.ipv4.dstAddr == 0xC0A80101) { // 192.168.1.1\n            standard_metadata.egress_spec = 255; // 转发到CPU端口\n        }\n    }\n}\n\n// 定义包转发逻辑\ncontrol egress(\n    inout headers_t hdr,\n    inout metadata_t meta,\n    inout standard_metadata_t standard_metadata\n) {\n    apply { }\n}\n\n// 定义包出站逻辑\ncontrol MyDeparser(\n    packet_out pkt,\n    in headers_t hdr\n) {\n    apply {\n        pkt.emit(hdr.ethernet);\n        pkt.emit(hdr.ipv4);\n    }\n}\n\nPipeline(SwitchIngressParser(),\n         SwitchIngress(),\n         SwitchIngressDeparser(),\n         SwitchEgressParser(),\n         SwitchEgress(),\n         SwitchEgressDeparser()) pipe;\n\nSwitch(pipe) main;\n"
  },
  {
    "instruction": "对源IP=192.168.0.1的数据包进行10Mbps的流量整形",
    "input": "",
    "output": "include <core.p4>\n#if __TARGET_TOFINO__ == 2\n#include <t2na.p4>\n#else\n#include <tna.p4>\n#endif\n\n#include \"common/headers.p4\"\n#include \"common/util.p4\"\n\n// 定义源IP和丢包概率\nheader ipv4_t {\n    bit<4>  version;\n    bit<4>  ihl;\n    bit<8>  diffserv;\n    bit<16> totalLen;\n    bit<16> identification;\n    bit<3>  flags;\n    bit<13> fragOffset;\n    bit<8>  ttl;\n    bit<8>  protocol;\n    bit<16> hdrChecksum;\n    bit<32> srcAddr;  // 这里是源IP地址\n    bit<32> dstAddr;\n}\n\n// \nstruct metadata_t {\n    bit<32> rate_limit_token;\n    bit<32> last_token_time;\n}\n\n// 定义解析后的数据包头\nstruct headers_t {\n    ethernet_t ethernet;\n    ipv4_t ipv4;\n}\n\n// 定义标准元数据\nstruct standard_metadata_t;\n\n// 定义包解析器\nparser MyParser(\n    packet_in pkt,\n    out headers_t hdr,\n    inout metadata_t meta,\n    inout standard_metadata_t standard_metadata\n) {\n    state start {\n        pkt.extract(hdr.ethernet);\n        transition select(hdr.ethernet.etherType) {\n            0x0800: parse_ipv4; // IPv4\n            default: accept;\n        }\n    }\n    state parse_ipv4 {\n        pkt.extract(hdr.ipv4);\n        transition accept;\n    }\n}\n\n// 定义转发逻辑\ncontrol ingress(\n    inout headers_t hdr,\n    inout metadata_t meta,\n    inout standard_metadata_t standard_metadata\n) {\n    action allow() {\n        standard_metadata.egress_spec = 1; // 转发到目标端口\n    }\n\n    action drop() {\n        standard_metadata.egress_spec = 0; // 丢弃包\n    }\n\n    apply {\n        if (hdr.ipv4.isValid() && hdr.ipv4.srcAddr == 0xC0A80001) { // 192.168.0.1\n            // 令牌桶算法：每秒钟生成一定数量的令牌（10Mbps）\n            bit<32> current_time = standard_metadata.timestamp;\n            bit<32> time_diff = current_time - meta.last_token_time;\n\n            // 每秒生成 1,250,000 字节的令牌\n            bit<32> tokens_to_add = time_diff * 1250000 / 1000000000;\n            meta.rate_limit_token = meta.rate_limit_token + tokens_to_add;\n\n            if (meta.rate_limit_token >= 1) { // 每个包消耗一个令牌\n                meta.rate_limit_token = meta.rate_limit_token - 1;\n                meta.last_token_time = current_time;\n                allow();\n            } else {\n                drop(); // 如果没有足够的令牌，丢弃包\n            }\n        }\n    }\n}\n\n// 定义包转发逻辑\ncontrol egress(\n    inout headers_t hdr,\n    inout metadata_t meta,\n    inout standard_metadata_t standard_metadata\n) {\n    apply { }\n}\n\n// 定义包出站逻辑\ncontrol MyDeparser(\n    packet_out pkt,\n    in headers_t hdr\n) {\n    apply {\n        pkt.emit(hdr.ethernet);\n        pkt.emit(hdr.ipv4);\n    }\n}\n\nPipeline(SwitchIngressParser(),\n         SwitchIngress(),\n         SwitchIngressDeparser(),\n         SwitchEgressParser(),\n         SwitchEgress(),\n         SwitchEgressDeparser()) pipe;\n\nSwitch(pipe) main;\n"
  },
  {
    "instruction": "对源IP=192.168.0.1的数据包实现概率为1%，乱序距离为10的乱序",
    "input": "",
    "output": "#include <core.p4>\n#if __TARGET_TOFINO__ == 2\n#include <t2na.p4>\n#else\n#include <tna.p4>\n#endif\n\n#include \"common/headers.p4\"\n#include \"common/util.p4\"\n\n// 定义源IP和丢包概率\nheader ipv4_t {\n    bit<4>  version;\n    bit<4>  ihl;\n    bit<8>  diffserv;\n    bit<16> totalLen;\n    bit<16> identification;\n    bit<3>  flags;\n    bit<13> fragOffset;\n    bit<8>  ttl;\n    bit<8>  protocol;\n    bit<16> hdrChecksum;\n    bit<32> srcAddr;  // 这里是源IP地址\n    bit<32> dstAddr;\n}\n\n// 定义元数据\nstruct metadata_t {\n    bit<32> seq_num;  // 用来记录已选中数据包的序号\n    bit<1> selected;   // 标记该数据包是否选中\n}\n\n// 定义解析后的数据包头\nstruct headers_t {\n    ethernet_t ethernet;\n    ipv4_t ipv4;\n}\n\n// 定义标准元数据\nstruct standard_metadata_t;\n\n// 定义包解析器\nparser MyParser(\n    packet_in pkt,\n    out headers_t hdr,\n    inout metadata_t meta,\n    inout standard_metadata_t standard_metadata\n) {\n    state start {\n        pkt.extract(hdr.ethernet);\n        transition select(hdr.ethernet.etherType) {\n            0x0800: parse_ipv4; // IPv4\n            default: accept;\n        }\n    }\n    state parse_ipv4 {\n        pkt.extract(hdr.ipv4);\n        transition accept;\n    }\n}\n\n// 定义转发逻辑\ncontrol ingress(\n    inout headers_t hdr,\n    inout metadata_t meta,\n    inout standard_metadata_t standard_metadata\n) {\n    action drop() {\n        standard_metadata.egress_spec = 255; // 丢弃包\n    }\n\n    action forward() {\n        standard_metadata.egress_spec = 1;  // 转发到端口 1\n    }\n\n    apply {\n        if (hdr.ipv4.isValid() && hdr.ipv4.srcAddr == 0xC0A80001) { // 192.168.0.1\n            // 1% 的概率选择数据包\n            if (random() % 100 < 1) {\n                meta.selected = 1;\n                meta.seq_num = 0;  // 初始化序列号\n            }\n        }\n\n        // 如果数据包已经选中，并且等待乱序处理\n        if (meta.selected == 1) {\n            if (meta.seq_num >= 10) {  // 乱序距离 10\n                forward();\n                meta.selected = 0;  // 重置选择标记\n            } else {\n                meta.seq_num = meta.seq_num + 1;  // 增加序列号\n                drop();  // 丢弃数据包\n            }\n        } else {\n            forward();  // 正常转发\n        }\n    }\n}\n\n// 定义包转发逻辑\ncontrol egress(\n    inout headers_t hdr,\n    inout metadata_t meta,\n    inout standard_metadata_t standard_metadata\n) {\n    apply { }\n}\n\n// 定义包出站逻辑\ncontrol MyDeparser(\n    packet_out pkt,\n    in headers_t hdr\n) {\n    apply {\n        pkt.emit(hdr.ethernet);\n        pkt.emit(hdr.ipv4);\n    }\n}\n\nPipeline(SwitchIngressParser(),\n         SwitchIngress(),\n         SwitchIngressDeparser(),\n         SwitchEgressParser(),\n         SwitchEgress(),\n         SwitchEgressDeparser()) pipe;\n\nSwitch(pipe) main;\n"
  },
  {
    "instruction": "对源IP前缀为192.168.0.0/16的数据包实现概率为1%的丢包",
    "input": "",
    "output": "#include <core.p4>\n#if __TARGET_TOFINO__ == 2\n#include <t2na.p4>\n#else\n#include <tna.p4>\n#endif\n\n#include \"common/headers.p4\"\n#include \"common/util.p4\"\n\n// 定义源IP和丢包概率\nheader ipv4_t {\n    bit<4>  version;\n    bit<4>  ihl;\n    bit<8>  diffserv;\n    bit<16> totalLen;\n    bit<16> identification;\n    bit<3>  flags;\n    bit<13> fragOffset;\n    bit<8>  ttl;\n    bit<8>  protocol;\n    bit<16> hdrChecksum;\n    bit<32> srcAddr;  // 这里是源IP地址\n    bit<32> dstAddr;\n}\n\n// 定义元数据\nstruct metadata_t {\n    bit<32> drop_decision; // 用于存储丢包决策\n}\n\n// ---------------------------------------------------------------------------\n// Ingress控制\n// ---------------------------------------------------------------------------\ncontrol SwitchIngress(\n        inout header_t hdr,\n        inout metadata_t ig_md,\n        in ingress_intrinsic_metadata_t ig_intr_md,\n        in ingress_intrinsic_metadata_from_parser_t ig_intr_prsr_md,\n        inout ingress_intrinsic_metadata_for_deparser_t ig_intr_dprsr_md,\n        inout ingress_intrinsic_metadata_for_tm_t ig_intr_tm_md) {\n\n    // 随机数生成器，模拟丢包\n    Random<bit<8>>() rnd1;   // 生成8位随机数\n\n    // 动作定义：丢包\n    action drop_packet() {\n        ig_md.drop_decision = 1; // 设置丢包决策\n    }\n\n    // 动作定义：正常转发\n    action forward_packet() {\n        ig_md.drop_decision = 0; // 设置正常转发\n    }\n\n    // 使用表格做源IP匹配和丢包决策\n    table drop_table {\n        key = {\n            hdr.ipv4.srcAddr: exact;\n        }\n        actions = {\n            drop_packet;\n            forward_packet;\n        }\n    }\n\n    apply {\n        // 源IP匹配：检查是否属于 192.168.0.0/16 网段\n        if (hdr.ipv4.srcAddr >= 0xC0A80000 && hdr.ipv4.srcAddr <= 0xC0A8FFFF) {\n            // 生成随机数来模拟丢包：1%的丢包概率\n            if (rnd1.get() < 2) { // 如果随机数小于2（即1%概率）\n                drop_packet(); // 丢包\n            } else {\n                forward_packet(); // 否则正常转发\n            }\n        } else {\n            forward_packet(); // 如果不匹配 192.168.x.x，直接转发\n        }\n    }\n}\n\n// ---------------------------------------------------------------------------\n// Ingress Deparser\n// ---------------------------------------------------------------------------\ncontrol SwitchIngressDeparser(\n        packet_out pkt,\n        inout header_t hdr,\n        in metadata_t ig_md,\n        in ingress_intrinsic_metadata_for_deparser_t ig_intr_dprsr_md) {\n\n    apply {\n        // 仅当没有丢包时才发送数据包\n        if (ig_md.drop_decision == 0) {\n            pkt.emit(hdr);\n        }\n    }\n}\n\n// ---------------------------------------------------------------------------\n// Egress\n// ---------------------------------------------------------------------------\ncontrol SwitchEgress(\n        inout header_t hdr,\n        inout metadata_t eg_md,\n        in egress_intrinsic_metadata_t eg_intr_md,\n        in egress_intrinsic_metadata_from_parser_t eg_intr_from_prsr,\n        inout egress_intrinsic_metadata_for_deparser_t eg_intr_md_for_dprsr,\n        inout egress_intrinsic_metadata_for_output_port_t eg_intr_md_for_oport) {\n\n    apply {\n     }\n}\n\n// ---------------------------------------------------------------------------\n// Egress Deparser\n// ---------------------------------------------------------------------------\ncontrol SwitchEgressDeparser(\n        packet_out pkt,\n        inout header_t hdr,\n        in metadata_t eg_md,\n        in egress_intrinsic_metadata_for_deparser_t eg_intr_dprsr_md) {\n\n    apply {\n        pkt.emit(hdr);\n    }\n}\n\nPipeline(SwitchIngressParser(),\n         SwitchIngress(),\n         SwitchIngressDeparser(),\n         SwitchEgressParser(),\n         SwitchEgress(),\n         SwitchEgressDeparser()) pipe;\n\nSwitch(pipe) main;\n"
  },
  {
    "instruction": "对目的IP=192.168.0.1的数据包开启ECN功能，低水线=10，高水线=20，标记概率为50%",
    "input": "",
    "output": "#include <core.p4>\n#if __TARGET_TOFINO__ == 2\n#include <t2na.p4>\n#else\n#include <tna.p4>\n#endif\n\n#include \"common/headers.p4\"\n#include \"common/util.p4\"\n\n// 定义 IP 头部结构\nheader ipv4_t {\n    bit<4>  version;\n    bit<4>  ihl;\n    bit<8>  diffserv;     // 用于 ECN 标记\n    bit<16> totalLen;\n    bit<16> identification;\n    bit<3>  flags;\n    bit<13> fragOffset;\n    bit<8>  ttl;\n    bit<8>  protocol;\n    bit<16> hdrChecksum;\n    bit<32> srcAddr;\n    bit<32> dstAddr;\n}\n\n// 定义元数据结构\nstruct metadata_t {\n    bit<32> ecn_mark;     // ECN 标记\n    bit<32> queue_len;   \n}\n\n// 低水位和高水位阈值\nconst bit<32> low_watermark = 10;  // 低水位阈值\nconst bit<32> high_watermark = 20; // 高水位阈值\n\n// ---------------------------------------------------------------------------\n// Ingress 控制逻辑\n// ---------------------------------------------------------------------------\ncontrol SwitchIngress(\n        inout header_t hdr,\n        inout metadata_t ig_md,\n        in ingress_intrinsic_metadata_t ig_intr_md,\n        in ingress_intrinsic_metadata_from_parser_t ig_intr_prsr_md,\n        inout ingress_intrinsic_metadata_for_deparser_t ig_intr_dprsr_md,\n        inout ingress_intrinsic_metadata_for_tm_t ig_intr_tm_md) {\n\n    // 动作：标记 ECN\n    action mark_ecn() {\n        hdr.ipv4.diffserv = hdr.ipv4.diffserv | 0x03;  // 设置低两位为 1 (ECN 标记)\n        ig_md.ecn_mark = 1;\n    }\n\n    // 动作：正常转发\n    action pass_packet() {\n        ig_md.ecn_mark = 0;\n    }\n\n    // 使用队列长度判断是否标记 ECN\n    apply {\n        // 如果目标 IP 是 192.168.0.1，进行 ECN 标记\n        if (hdr.ipv4.dstAddr == 0xC0A80001) {  // 192.168.0.1\n            // 队列长度模拟\n            bit<32> queue_length = ig_md.queue_len;  // 队列长度由元数据传递\n\n            // 判断队列长度与水位阈值\n            if (queue_length > high_watermark) {\n                // 高水位标记 ECN\n                mark_ecn();\n            } else if (queue_length > low_watermark) {\n                // 低水位，根据概率标记ECN（50% 的概率）\n                if (rnd1.get() < 50) {\n                    mark_ecn();\n                } else {\n                    pass_packet();\n                }\n            } else {\n                pass_packet();  // 队列长度未超出低水位，直接通过\n            }\n        } else {\n            pass_packet();  // 其他目标 IP 不标记 ECN\n        }\n    }\n}\n\n// ---------------------------------------------------------------------------\n// Ingress Deparser\n// ---------------------------------------------------------------------------\ncontrol SwitchIngressDeparser(\n        packet_out pkt,\n        inout header_t hdr,\n        in metadata_t ig_md,\n        in ingress_intrinsic_metadata_for_deparser_t ig_intr_dprsr_md) {\n\n    apply {\n        // 如果标记了 ECN，就设置 ECN 标记位\n        if (ig_md.ecn_mark == 1) {\n            hdr.ipv4.diffserv = hdr.ipv4.diffserv | 0x03;  // 设置ECN标记\n        }\n        pkt.emit(hdr);  // 发射数据包\n    }\n}\n\n// ---------------------------------------------------------------------------\n// Egress 控制逻辑\n// ---------------------------------------------------------------------------\ncontrol SwitchEgress(\n        inout header_t hdr,\n        inout metadata_t eg_md,\n        in egress_intrinsic_metadata_t eg_intr_md,\n        in egress_intrinsic_metadata_from_parser_t eg_intr_from_prsr,\n        inout egress_intrinsic_metadata_for_deparser_t eg_intr_md_for_dprsr,\n        inout egress_intrinsic_metadata_for_output_port_t eg_intr_md_for_oport) {\n\n    apply {\n        // 在 Egress 阶段不做特殊处理\n    }\n}\n\n// ---------------------------------------------------------------------------\n// Egress Deparser\n// ---------------------------------------------------------------------------\ncontrol SwitchEgressDeparser(\n        packet_out pkt,\n        inout header_t hdr,\n        in metadata_t eg_md,\n        in egress_intrinsic_metadata_for_deparser_t eg_intr_dprsr_md) {\n\n    apply {\n        pkt.emit(hdr);\n    }\n}\n\nPipeline(SwitchIngressParser(),\n         SwitchIngress(),\n         SwitchIngressDeparser(),\n         SwitchEgressParser(),\n         SwitchEgress(),\n         SwitchEgressDeparser()) pipe;\n\nSwitch(pipe) main;"
  },
  {
    "instruction": "每5秒读取一次交换机吞吐值",
    "input": "",
    "output": "import grpc\nimport time\nfrom p4runtime_lib.switch import SwitchConnection\nfrom p4runtime_lib.packet import Packet\nfrom p4runtime_lib.helper import p4runtime_pb2\nfrom google.protobuf import empty_pb2\n\nclass P4Controller:\n    def __init__(self, switch_ip, switch_port, p4info_file, tofino_json_file):\n        self.switch_ip = switch_ip\n        self.switch_port = switch_port\n        self.p4info_file = p4info_file\n        self.tofino_json_file = tofino_json_file\n        self.connection = None\n\n    def connect(self):\n        """连接到P4交换机"""\n        # 创建与P4交换机的连接\n        self.connection = SwitchConnection(\n            name=\"switch\",\n            address=(self.switch_ip, self.switch_port),\n            device_id=0,\n            proto_dump_file=\"controller.p4runtime.pb.txt\",\n            p4info_file=self.p4info_file,\n            tofino_file=self.tofino_json_file,\n        )\n        self.connection.MasterArbitrationUpdate()\n\n    def read_forwarding_stats(self):\n        """读取包转发数"""\n        try:\n            # 从交换机读取统计信息\n            print(\"Reading forwarding statistics from switch...\")\n            response = self.connection.ReadTableEntryStats()\n            \n            # 打印统计信息            \n            for entry in response.entry_stats:\n                print(f\"Entry: {entry.key}\")\n                print(f\"Packet Count: {entry.packet_count}\")\n                print(f\"Byte Count: {entry.byte_count}\")\n        except grpc.RpcError as e:\n            print(f\"Error reading statistics: {e}\")\n\n    def run(self):\n        """启动控制器并读取统计信息"""\n        self.connect()\n        while True:\n            self.read_forwarding_stats()\n            time.sleep(5)  # 每5秒读取一次统计信息\n\n\nif __name__ == \"__main__\":\n    switch_ip = \"192.168.0.1\"  # P4交换机的IP\n    switch_port = 50051  # P4Runtime端口（默认50051）\n    p4info_file = \"build/p4info.txt\"  # P4Info文件路径\n    tofino_json_file = \"build/simple_switch.json\"  # P4程序的编译文件\n\n    controller = P4Controller(switch_ip, switch_port, p4info_file, tofino_json_file)\n    controller.run()"
  },
  {
    "instruction": "在CPU上对从网卡eth1收到的数据包，进行10Mbps的流量整形，设置目的IP为192.168.0.1后，从eth1中发送出去",
    "input": "",
    "output": "#include <stdio.h>\n#include <stdlib.h>\n#include <pcap.h>\n#include <netinet/ip.h>\n#include <netinet/udp.h>\n#include <netinet/tcp.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <net/if.h>\n#include <linux/if_packet.h>\n#include <string.h>\n#include <unistd.h>\n#include <time.h>\n\n#define MAX_PACKET_SIZE 65536\n#define SHAPER_RATE 10000000 // 10 Mbps\n\n// 用于计算流量整形速率\nunsigned long last_time = 0;\nunsigned long last_bytes = 0;\nunsigned long rate = SHAPER_RATE;\n\n// 处理以太网数据包并修改目的IP\nvoid process_packet(const u_char *packet, int packet_len, struct pcap_pkthdr header, int sockfd) {\n    struct ip *ip_header = (struct ip *)(packet + 14); // 以太网头后面的IP头\n    struct sockaddr_ll sa;\n    char new_packet[MAX_PACKET_SIZE];\n    int new_packet_len;\n\n    // 修改目的IP地址为 192.168.0.1\n    ip_header->ip_dst.s_addr = inet_addr(\"192.168.0.1\");\n\n    // 将修改后的包复制到新包中\n    memcpy(new_packet, packet, packet_len);\n    new_packet_len = packet_len;\n\n    // 设置socket地址\n    memset(&sa, 0, sizeof(struct sockaddr_ll));\n    sa.sll_protocol = htons(ETH_P_IP);  // 设置为IP协议\n    sa.sll_ifindex = if_nametoindex(\"eth1\");  // 使用eth1接口发送\n\n    // 发送修改后的包\n    sendto(sockfd, new_packet, new_packet_len, 0, (struct sockaddr*)&sa, sizeof(struct sockaddr_ll));\n}\n\n// 获取当前时间（毫秒）\nunsigned long get_current_time() {\n    struct timespec ts;\n    clock_gettime(CLOCK_MONOTONIC, &ts);\n    return ts.tv_sec * 1000 + ts.tv_nsec / 1000000;\n}\n\n// 计算是否需要等待以保证10Mbps的速率\nvoid shape_traffic(unsigned long bytes_to_send) {\n    unsigned long current_time = get_current_time();\n    unsigned long elapsed_time = current_time - last_time;\n    unsigned long current_bytes = bytes_to_send;\n\n    if (elapsed_time == 0) {\n        return;\n    }\n\n    // 如果发送的字节数超出了期望速率，需要等待\n    unsigned long expected_bytes = rate * elapsed_time / 1000;  // bytes expected for 1ms\n    if (current_bytes > expected_bytes) {\n        unsigned long wait_time = (current_bytes - expected_bytes) * 1000 / rate;\n        usleep(wait_time);  // 延时等待\n    }\n\n    last_time = current_time;\n    last_bytes = current_bytes;\n}\n\nint main() {\n    pcap_t *handle;\n    struct pcap_pkthdr header;\n    const u_char *packet;\n    char errbuf[PCAP_ERRBUF_SIZE];\n    struct sockaddr_ll sa;\n    int sockfd;\n\n    // 打开网卡eth1进行抓包\n    handle = pcap_open_live(\"eth1\", MAX_PACKET_SIZE, 1, 1000, errbuf);\n    if (handle == NULL) {\n        printf(\"Error opening pcap: %s\\n\", errbuf);\n        return -1;\n    }\n\n    // 创建原始套接字用于发送数据包\n    sockfd = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_IP));\n    if (sockfd == -1) {\n        perror(\"Socket creation failed\");\n        return -1;\n    }\n\n    while (1) {\n        packet = pcap_next(handle, &header);\n\n        // 判断流量整形条件并等待\n        shape_traffic(header.len);\n\n        // 处理接收到的包并修改目的IP\n        process_packet(packet, header.len, header, sockfd);\n    }\n\n    // 关闭pcap句柄和套接字\n    pcap_close(handle);\n    close(sockfd);\n\n    return 0;\n}"
  }
]