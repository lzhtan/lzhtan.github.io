[
  {
    "instruction": "Implement 5% random packet loss for packets with source IP=192.168.0.1",
    "input": "",
    "output": "include <core.p4>\n#if __TARGET_TOFINO__ == 2\n#include <t2na.p4>\n#else\n#include <tna.p4>\n#endif\n\n#include \"common/headers.p4\"\n#include \"common/util.p4\"\n// Define packet headers\nheader ethernet_t {\n    bit<48> dstAddr;\n    bit<48> srcAddr;\n    bit<16> etherType;\n}\n\nheader ipv4_t {\n    bit<4>  version;\n    bit<4>  ihl;\n    bit<8>  diffserv;\n    bit<16> totalLen;\n    bit<16> identification;\n    bit<3>  flags;\n    bit<13> fragOffset;\n    bit<8>  ttl;\n    bit<8>  protocol;\n    bit<16> hdrChecksum;\n    bit<32> srcAddr;\n    bit<32> dstAddr;\n}\n\n// Define metadata\nstruct metadata_t { }\n\n// Define parsed packet headers\nstruct headers_t {\n    ethernet_t ethernet;\n    ipv4_t ipv4;\n}\n\n// Define standard metadata\nstruct standard_metadata_t;\n\n// Define packet parser\nparser MyParser(\n    packet_in pkt,\n    out headers_t hdr,\n    inout metadata_t meta,\n    inout standard_metadata_t standard_metadata\n) {\n    state start {\n        pkt.extract(hdr.ethernet);\n        transition select(hdr.ethernet.etherType) {\n            0x0800: parse_ipv4; // IPv4\n            default: accept;\n        }\n    }\n    state parse_ipv4 {\n        pkt.extract(hdr.ipv4);\n        transition accept;\n    }\n}\n\n// Define forwarding logic\ncontrol ingress(\n    inout headers_t hdr,\n    inout metadata_t meta,\n    inout standard_metadata_t standard_metadata\n) {\n    action drop() {\n        standard_metadata.egress_spec = 0; // Drop packet\n    }\n\n    apply {\n        if (hdr.ipv4.isValid() && hdr.ipv4.srcAddr == 0xC0A80001) { // 192.168.0.1\n            // Simulate random packet loss\n            if (random() % 100 < 5) { // 5% probability\n                drop();\n            }\n        }\n    }\n}\n\n// Define packet forwarding logic\ncontrol egress(\n    inout headers_t hdr,\n    inout metadata_t meta,\n    inout standard_metadata_t standard_metadata\n) {\n    apply { }\n}\n\n// Define packet deparser\ncontrol MyDeparser(\n    packet_out pkt,\n    in headers_t hdr\n) {\n    apply {\n        pkt.emit(hdr.ethernet);\n        pkt.emit(hdr.ipv4);\n    }\n}\n\nPipeline(SwitchIngressParser(),\n         SwitchIngress(),\n         SwitchIngressDeparser(),\n         SwitchEgressParser(),\n         SwitchEgress(),\n         SwitchEgressDeparser()) pipe;\n\nSwitch(pipe) main;\n"
  },
  {
    "instruction": "Modify the source IP to 192.168.1.1 for packets with destination IP=192.168.0.1",
    "input": "",
    "output": "include <core.p4>\n#if __TARGET_TOFINO__ == 2\n#include <t2na.p4>\n#else\n#include <tna.p4>\n#endif\n\n#include \"common/headers.p4\"\n#include \"common/util.p4\"\n// Define packet headers\nheader ethernet_t {\n    bit<48> dstAddr;\n    bit<48> srcAddr;\n    bit<16> etherType;\n}\n\nheader ipv4_t {\n    bit<4>  version;\n    bit<4>  ihl;\n    bit<8>  diffserv;\n    bit<16> totalLen;\n    bit<16> identification;\n    bit<3>  flags;\n    bit<13> fragOffset;\n    bit<8>  ttl;\n    bit<8>  protocol;\n    bit<16> hdrChecksum;\n    bit<32> srcAddr;\n    bit<32> dstAddr;\n}\n\n// Define metadata\nstruct metadata_t { }\n\n// Define parsed packet headers\nstruct headers_t {\n    ethernet_t ethernet;\n    ipv4_t ipv4;\n}\n\n// Define standard metadata\nstruct standard_metadata_t;\n\n// Define packet parser\nparser MyParser(\n    packet_in pkt,\n    out headers_t hdr,\n    inout metadata_t meta,\n    inout standard_metadata_t standard_metadata\n) {\n    state start {\n        pkt.extract(hdr.ethernet);\n        transition select(hdr.ethernet.etherType) {\n            0x0800: parse_ipv4; // IPv4\n            default: accept;\n        }\n    }\n    state parse_ipv4 {\n        pkt.extract(hdr.ipv4);\n        transition accept;\n    }\n}\n\n// Define forwarding logic\ncontrol ingress(\n    inout headers_t hdr,\n    inout metadata_t meta,\n    inout standard_metadata_t standard_metadata\n) {\n    apply {\n        if (hdr.ipv4.isValid() && hdr.ipv4.dstAddr == 0xC0A80001) { // 192.168.0.1\n            hdr.ipv4.srcAddr = 0xC0A80101; // Modify source IP to 192.168.1.1\n        }\n    }\n}\n\n// Define packet forwarding logic\ncontrol egress(\n    inout headers_t hdr,\n    inout metadata_t meta,\n    inout standard_metadata_t standard_metadata\n) {\n    apply { }\n}\n\n// Define packet deparser\ncontrol MyDeparser(\n    packet_out pkt,\n    in headers_t hdr\n) {\n    apply {\n        pkt.emit(hdr.ethernet);\n        pkt.emit(hdr.ipv4);\n    }\n}\n\nPipeline(SwitchIngressParser(),\n         SwitchIngress(),\n         SwitchIngressDeparser(),\n         SwitchEgressParser(),\n         SwitchEgress(),\n         SwitchEgressDeparser()) pipe;\n\nSwitch(pipe) main;\n"
  },
  {
    "instruction": "Forward packets with destination IP=192.168.1.1 to the CPU port",
    "input": "",
    "output": "include <core.p4>\n#if __TARGET_TOFINO__ == 2\n#include <t2na.p4>\n#else\n#include <tna.p4>\n#endif\n\n#include \"common/headers.p4\"\n#include \"common/util.p4\"\n// Define packet headers\nheader ethernet_t {\n    bit<48> dstAddr;\n    bit<48> srcAddr;\n    bit<16> etherType;\n}\n\nheader ipv4_t {\n    bit<4>  version;\n    bit<4>  ihl;\n    bit<8>  diffserv;\n    bit<16> totalLen;\n    bit<16> identification;\n    bit<3>  flags;\n    bit<13> fragOffset;\n    bit<8>  ttl;\n    bit<8>  protocol;\n    bit<16> hdrChecksum;\n    bit<32> srcAddr;\n    bit<32> dstAddr;\n}\n\n// Define metadata\nstruct metadata_t { }\n\n// Define parsed packet headers\nstruct headers_t {\n    ethernet_t ethernet;\n    ipv4_t ipv4;\n}\n\n// Define standard metadata\nstruct standard_metadata_t;\n\n// Define packet parser\nparser MyParser(\n    packet_in pkt,\n    out headers_t hdr,\n    inout metadata_t meta,\n    inout standard_metadata_t standard_metadata\n) {\n    state start {\n        pkt.extract(hdr.ethernet);\n        transition select(hdr.ethernet.etherType) {\n            0x0800: parse_ipv4; // IPv4\n            default: accept;\n        }\n    }\n    state parse_ipv4 {\n        pkt.extract(hdr.ipv4);\n        transition accept;\n    }\n}\n\n// Define forwarding logic\ncontrol ingress(\n    inout headers_t hdr,\n    inout metadata_t meta,\n    inout standard_metadata_t standard_metadata\n) {\n    apply {\n        if (hdr.ipv4.isValid() && hdr.ipv4.dstAddr == 0xC0A80101) { // 192.168.1.1\n            standard_metadata.egress_spec = 255; // Forward to CPU port\n        }\n    }\n}\n\n// Define packet forwarding logic\ncontrol egress(\n    inout headers_t hdr,\n    inout metadata_t meta,\n    inout standard_metadata_t standard_metadata\n) {\n    apply { }\n}\n\n// Define packet deparser\ncontrol MyDeparser(\n    packet_out pkt,\n    in headers_t hdr\n) {\n    apply {\n        pkt.emit(hdr.ethernet);\n        pkt.emit(hdr.ipv4);\n    }\n}\n\nPipeline(SwitchIngressParser(),\n         SwitchIngress(),\n         SwitchIngressDeparser(),\n         SwitchEgressParser(),\n         SwitchEgress(),\n         SwitchEgressDeparser()) pipe;\n\nSwitch(pipe) main;\n"
  },
  {
    "instruction": "Implement 10Mbps traffic shaping for packets with source IP=192.168.0.1",
    "input": "",
    "output": "include <core.p4>\n#if __TARGET_TOFINO__ == 2\n#include <t2na.p4>\n#else\n#include <tna.p4>\n#endif\n\n#include \"common/headers.p4\"\n#include \"common/util.p4\"\n\n// Define source IP and packet loss probability\nheader ipv4_t {\n    bit<4>  version;\n    bit<4>  ihl;\n    bit<8>  diffserv;\n    bit<16> totalLen;\n    bit<16> identification;\n    bit<3>  flags;\n    bit<13> fragOffset;\n    bit<8>  ttl;\n    bit<8>  protocol;\n    bit<16> hdrChecksum;\n    bit<32> srcAddr;  // Source IP address\n    bit<32> dstAddr;\n}\n\n// \nstruct metadata_t {\n    bit<32> rate_limit_token;\n    bit<32> last_token_time;\n}\n\n// Define parsed packet headers\nstruct headers_t {\n    ethernet_t ethernet;\n    ipv4_t ipv4;\n}\n\n// Define standard metadata\nstruct standard_metadata_t;\n\n// Define packet parser\nparser MyParser(\n    packet_in pkt,\n    out headers_t hdr,\n    inout metadata_t meta,\n    inout standard_metadata_t standard_metadata\n) {\n    state start {\n        pkt.extract(hdr.ethernet);\n        transition select(hdr.ethernet.etherType) {\n            0x0800: parse_ipv4; // IPv4\n            default: accept;\n        }\n    }\n    state parse_ipv4 {\n        pkt.extract(hdr.ipv4);\n        transition accept;\n    }\n}\n\n// Define forwarding logic\ncontrol ingress(\n    inout headers_t hdr,\n    inout metadata_t meta,\n    inout standard_metadata_t standard_metadata\n) {\n    action allow() {\n        standard_metadata.egress_spec = 1; // Forward to target port\n    }\n\n    action drop() {\n        standard_metadata.egress_spec = 0; // Drop packet\n    }\n\n    apply {\n        if (hdr.ipv4.isValid() && hdr.ipv4.srcAddr == 0xC0A80001) { // 192.168.0.1\n            // Token bucket algorithm: generate a certain number of tokens per second (10Mbps)\n            bit<32> current_time = standard_metadata.timestamp;\n            bit<32> time_diff = current_time - meta.last_token_time;\n\n            // Generate 1,250,000 bytes of tokens per second\n            bit<32> tokens_to_add = time_diff * 1250000 / 1000000000;\n            meta.rate_limit_token = meta.rate_limit_token + tokens_to_add;\n\n            if (meta.rate_limit_token >= 1) { // Each packet consumes one token\n                meta.rate_limit_token = meta.rate_limit_token - 1;\n                meta.last_token_time = current_time;\n                allow();\n            } else {\n                drop(); // Drop packet if not enough tokens\n            }\n        }\n    }\n}\n\n// Define packet forwarding logic\ncontrol egress(\n    inout headers_t hdr,\n    inout metadata_t meta,\n    inout standard_metadata_t standard_metadata\n) {\n    apply { }\n}\n\n// Define packet deparser\ncontrol MyDeparser(\n    packet_out pkt,\n    in headers_t hdr\n) {\n    apply {\n        pkt.emit(hdr.ethernet);\n        pkt.emit(hdr.ipv4);\n    }\n}\n\nPipeline(SwitchIngressParser(),\n         SwitchIngress(),\n         SwitchIngressDeparser(),\n         SwitchEgressParser(),\n         SwitchEgress(),\n         SwitchEgressDeparser()) pipe;\n\nSwitch(pipe) main;\n"
  },
  {
    "instruction": "Implement 1% probability reordering with a reordering distance of 10 for packets with source IP=192.168.0.1",
    "input": "",
    "output": "#include <core.p4>\n#if __TARGET_TOFINO__ == 2\n#include <t2na.p4>\n#else\n#include <tna.p4>\n#endif\n\n#include \"common/headers.p4\"\n#include \"common/util.p4\"\n\n// Define source IP and packet loss probability\nheader ipv4_t {\n    bit<4>  version;\n    bit<4>  ihl;\n    bit<8>  diffserv;\n    bit<16> totalLen;\n    bit<16> identification;\n    bit<3>  flags;\n    bit<13> fragOffset;\n    bit<8>  ttl;\n    bit<8>  protocol;\n    bit<16> hdrChecksum;\n    bit<32> srcAddr;  // Source IP address\n    bit<32> dstAddr;\n}\n\n// Define metadata\nstruct metadata_t {\n    bit<32> seq_num;  // Record the sequence number of the selected packet\n    bit<1> selected;   // Mark whether the packet is selected\n}\n\n// Define parsed packet headers\nstruct headers_t {\n    ethernet_t ethernet;\n    ipv4_t ipv4;\n}\n\n// Define standard metadata\nstruct standard_metadata_t;\n\n// Define packet parser\nparser MyParser(\n    packet_in pkt,\n    out headers_t hdr,\n    inout metadata_t meta,\n    inout standard_metadata_t standard_metadata\n) {\n    state start {\n        pkt.extract(hdr.ethernet);\n        transition select(hdr.ethernet.etherType) {\n            0x0800: parse_ipv4; // IPv4\n            default: accept;\n        }\n    }\n    state parse_ipv4 {\n        pkt.extract(hdr.ipv4);\n        transition accept;\n    }\n}\n\n// Define forwarding logic\ncontrol ingress(\n    inout headers_t hdr,\n    inout metadata_t meta,\n    inout standard_metadata_t standard_metadata\n) {\n    action drop() {\n        standard_metadata.egress_spec = 255; // Drop packet\n    }\n\n    action forward() {\n        standard_metadata.egress_spec = 1;  // Forward to port 1\n    }\n\n    apply {\n        if (hdr.ipv4.isValid() && hdr.ipv4.srcAddr == 0xC0A80001) { // 192.168.0.1\n            // 1% probability to select packet\n            if (random() % 100 < 1) {\n                meta.selected = 1;\n                meta.seq_num = 0;  // Initialize sequence number\n            }\n        }\n\n        // If the packet is selected and waiting for reordering\n        if (meta.selected == 1) {\n            if (meta.seq_num >= 10) {  // Reordering distance 10\n                forward();\n                meta.selected = 0;  // Reset selection flag\n            } else {\n                meta.seq_num = meta.seq_num + 1;  // Increase sequence number\n                drop();  // Drop packet\n            }\n        } else {\n            forward();  // Normal forwarding\n        }\n    }\n}\n\n// Define packet forwarding logic\ncontrol egress(\n    inout headers_t hdr,\n    inout metadata_t meta,\n    inout standard_metadata_t standard_metadata\n) {\n    apply { }\n}\n\n// Define packet deparser\ncontrol MyDeparser(\n    packet_out pkt,\n    in headers_t hdr\n) {\n    apply {\n        pkt.emit(hdr.ethernet);\n        pkt.emit(hdr.ipv4);\n    }\n}\n\nPipeline(SwitchIngressParser(),\n         SwitchIngress(),\n         SwitchIngressDeparser(),\n         SwitchEgressParser(),\n         SwitchEgress(),\n         SwitchEgressDeparser()) pipe;\n\nSwitch(pipe) main;\n"
  },
  {
    "instruction": "Implement 1% packet loss for packets with source IP prefix 192.168.0.0/16",
    "input": "",
    "output": "#include <core.p4>\n#if __TARGET_TOFINO__ == 2\n#include <t2na.p4>\n#else\n#include <tna.p4>\n#endif\n\n#include \"common/headers.p4\"\n#include \"common/util.p4\"\n\n// Define source IP and packet loss probability\nheader ipv4_t {\n    bit<4>  version;\n    bit<4>  ihl;\n    bit<8>  diffserv;\n    bit<16> totalLen;\n    bit<16> identification;\n    bit<3>  flags;\n    bit<13> fragOffset;\n    bit<8>  ttl;\n    bit<8>  protocol;\n    bit<16> hdrChecksum;\n    bit<32> srcAddr;  // Source IP address\n    bit<32> dstAddr;\n}\n\n// Define metadata\nstruct metadata_t {\n    bit<32> drop_decision; // Store packet drop decision\n}\n\n// ---------------------------------------------------------------------------\n// Ingress control\n// ---------------------------------------------------------------------------\ncontrol SwitchIngress(\n        inout header_t hdr,\n        inout metadata_t ig_md,\n        in ingress_intrinsic_metadata_t ig_intr_md,\n        in ingress_intrinsic_metadata_from_parser_t ig_intr_prsr_md,\n        inout ingress_intrinsic_metadata_for_deparser_t ig_intr_dprsr_md,\n        inout ingress_intrinsic_metadata_for_tm_t ig_intr_tm_md) {\n\n    // Random number generator to simulate packet loss\n    Random<bit<8>>() rnd1;   // Generate 8-bit random number\n\n    // Action definition: drop packet\n    action drop_packet() {\n        ig_md.drop_decision = 1; // Set drop decision\n    }\n\n    // Action definition: forward packet\n    action forward_packet() {\n        ig_md.drop_decision = 0; // Set forward decision\n    }\n\n    // Use table for source IP matching and drop decision\n    table drop_table {\n        key = {\n            hdr.ipv4.srcAddr: exact;\n        }\n        actions = {\n            drop_packet;\n            forward_packet;\n        }\n    }\n\n    apply {\n        // Source IP matching: check if it belongs to 192.168.0.0/16 subnet\n        if (hdr.ipv4.srcAddr >= 0xC0A80000 && hdr.ipv4.srcAddr <= 0xC0A8FFFF) {\n            // Generate random number to simulate packet loss: 1% loss probability\n            if (rnd1.get() < 2) { // If random number is less than 2 (1% probability)\n                drop_packet(); // Drop packet\n            } else {\n                forward_packet(); // Otherwise, forward normally\n            }\n        } else {\n            forward_packet(); // If not matching 192.168.x.x, forward directly\n        }\n    }\n}\n\n// ---------------------------------------------------------------------------\n// Ingress Deparser\n// ---------------------------------------------------------------------------\ncontrol SwitchIngressDeparser(\n        packet_out pkt,\n        inout header_t hdr,\n        in metadata_t ig_md,\n        in ingress_intrinsic_metadata_for_deparser_t ig_intr_dprsr_md) {\n\n    apply {\n        // Only send packet if not dropped\n        if (ig_md.drop_decision == 0) {\n            pkt.emit(hdr);\n        }\n    }\n}\n\n// ---------------------------------------------------------------------------\n// Egress\n// ---------------------------------------------------------------------------\ncontrol SwitchEgress(\n        inout header_t hdr,\n        inout metadata_t eg_md,\n        in egress_intrinsic_metadata_t eg_intr_md,\n        in egress_intrinsic_metadata_from_parser_t eg_intr_from_prsr,\n        inout egress_intrinsic_metadata_for_deparser_t eg_intr_md_for_dprsr,\n        inout egress_intrinsic_metadata_for_output_port_t eg_intr_md_for_oport) {\n\n    apply {\n     }\n}\n\n// ---------------------------------------------------------------------------\n// Egress Deparser\n// ---------------------------------------------------------------------------\ncontrol SwitchEgressDeparser(\n        packet_out pkt,\n        inout header_t hdr,\n        in metadata_t eg_md,\n        in egress_intrinsic_metadata_for_deparser_t eg_intr_dprsr_md) {\n\n    apply {\n        pkt.emit(hdr);\n    }\n}\n\nPipeline(SwitchIngressParser(),\n         SwitchIngress(),\n         SwitchIngressDeparser(),\n         SwitchEgressParser(),\n         SwitchEgress(),\n         SwitchEgressDeparser()) pipe;\n\nSwitch(pipe) main;\n"
  },
  {
    "instruction": "Enable ECN for packets with destination IP=192.168.0.1, low watermark=10, high watermark=20, marking probability=50%",
    "input": "",
    "output": "#include <core.p4>\n#if __TARGET_TOFINO__ == 2\n#include <t2na.p4>\n#else\n#include <tna.p4>\n#endif\n\n#include \"common/headers.p4\"\n#include \"common/util.p4\"\n\n// Define IP header structure\nheader ipv4_t {\n    bit<4>  version;\n    bit<4>  ihl;\n    bit<8>  diffserv;     // For ECN marking\n    bit<16> totalLen;\n    bit<16> identification;\n    bit<3>  flags;\n    bit<13> fragOffset;\n    bit<8>  ttl;\n    bit<8>  protocol;\n    bit<16> hdrChecksum;\n    bit<32> srcAddr;\n    bit<32> dstAddr;\n}\n\n// Define metadata structure\nstruct metadata_t {\n    bit<32> ecn_mark;     // ECN marking\n    bit<32> queue_len;   \n}\n\n// Low and high watermark thresholds\nconst bit<32> low_watermark = 10;  // Low watermark threshold\nconst bit<32> high_watermark = 20; // High watermark threshold\n\n// ---------------------------------------------------------------------------\n// Ingress control logic\n// ---------------------------------------------------------------------------\ncontrol SwitchIngress(\n        inout header_t hdr,\n        inout metadata_t ig_md,\n        in ingress_intrinsic_metadata_t ig_intr_md,\n        in ingress_intrinsic_metadata_from_parser_t ig_intr_prsr_md,\n        inout ingress_intrinsic_metadata_for_deparser_t ig_intr_dprsr_md,\n        inout ingress_intrinsic_metadata_for_tm_t ig_intr_tm_md) {\n\n    // Action: mark ECN\n    action mark_ecn() {\n        hdr.ipv4.diffserv = hdr.ipv4.diffserv | 0x03;  // Set the lowest two bits to 1 (ECN marking)\n        ig_md.ecn_mark = 1;\n    }\n\n    // Action: pass packet\n    action pass_packet() {\n        ig_md.ecn_mark = 0;\n    }\n\n    // Use queue length to determine whether to mark ECN\n    apply {\n        // If destination IP is 192.168.0.1, perform ECN marking\n        if (hdr.ipv4.dstAddr == 0xC0A80001) {  // 192.168.0.1\n            // Simulate queue length\n            bit<32> queue_length = ig_md.queue_len;  // Queue length passed by metadata\n\n            // Determine queue length against watermark thresholds\n            if (queue_length > high_watermark) {\n                // High watermark, mark ECN\n                mark_ecn();\n            } else if (queue_length > low_watermark) {\n                // Low watermark, mark ECN with 50% probability\n                if (rnd1.get() < 50) {\n                    mark_ecn();\n                } else {\n                    pass_packet();\n                }\n            } else {\n                pass_packet();  // Queue length below low watermark, pass directly\n            }\n        } else {\n            pass_packet();  // Other destination IPs do not mark ECN\n        }\n    }\n}\n\n// ---------------------------------------------------------------------------\n// Ingress Deparser\n// ---------------------------------------------------------------------------\ncontrol SwitchIngressDeparser(\n        packet_out pkt,\n        inout header_t hdr,\n        in metadata_t ig_md,\n        in ingress_intrinsic_metadata_for_deparser_t ig_intr_dprsr_md) {\n\n    apply {\n        // If ECN is marked, set ECN marking bits\n        if (ig_md.ecn_mark == 1) {\n            hdr.ipv4.diffserv = hdr.ipv4.diffserv | 0x03;  // Set ECN marking\n        }\n        pkt.emit(hdr);  // Emit packet\n    }\n}\n\n// ---------------------------------------------------------------------------\n// Egress control logic\n// ---------------------------------------------------------------------------\ncontrol SwitchEgress(\n        inout header_t hdr,\n        inout metadata_t eg_md,\n        in egress_intrinsic_metadata_t eg_intr_md,\n        in egress_intrinsic_metadata_from_parser_t eg_intr_from_prsr,\n        inout egress_intrinsic_metadata_for_deparser_t eg_intr_md_for_dprsr,\n        inout egress_intrinsic_metadata_for_output_port_t eg_intr_md_for_oport) {\n\n    apply {\n        // No special processing in Egress stage\n    }\n}\n\n// ---------------------------------------------------------------------------\n// Egress Deparser\n// ---------------------------------------------------------------------------\ncontrol SwitchEgressDeparser(\n        packet_out pkt,\n        inout header_t hdr,\n        in metadata_t eg_md,\n        in egress_intrinsic_metadata_for_deparser_t eg_intr_dprsr_md) {\n\n    apply {\n        pkt.emit(hdr);\n    }\n}\n\nPipeline(SwitchIngressParser(),\n         SwitchIngress(),\n         SwitchIngressDeparser(),\n         SwitchEgressParser(),\n         SwitchEgress(),\n         SwitchEgressDeparser()) pipe;\n\nSwitch(pipe) main;\n"
  },
  {
    "instruction": "Read switch throughput value every 5 seconds",
    "input": "",
    "output": "import grpc\nimport time\nfrom p4runtime_lib.switch import SwitchConnection\nfrom p4runtime_lib.packet import Packet\nfrom p4runtime_lib.helper import p4runtime_pb2\nfrom google.protobuf import empty_pb2\n\nclass P4Controller:\n    def __init__(self, switch_ip, switch_port, p4info_file, tofino_json_file):\n        self.switch_ip = switch_ip\n        self.switch_port = switch_port\n        self.p4info_file = p4info_file\n        self.tofino_json_file = tofino_json_file\n        self.connection = None\n\n    def connect(self):\n        \"\"\"Connect to P4 switch\"\"\"\n        # Create connection to P4 switch\n        self.connection = SwitchConnection(\n            name=\"switch\",\n            address=(self.switch_ip, self.switch_port),\n            device_id=0,\n            proto_dump_file=\"controller.p4runtime.pb.txt\",\n            p4info_file=self.p4info_file,\n            tofino_file=self.tofino_json_file,\n        )\n        self.connection.MasterArbitrationUpdate()\n\n    def read_forwarding_stats(self):\n        \"\"\"Read packet forwarding statistics\"\"\"\n        try:\n            # Read statistics from switch\n            print(\"Reading forwarding statistics from switch...\")\n            response = self.connection.ReadTableEntryStats()\n            \n            # Print statistics            \n            for entry in response.entry_stats:\n                print(f\"Entry: {entry.key}\")\n                print(f\"Packet Count: {entry.packet_count}\")\n                print(f\"Byte Count: {entry.byte_count}\")\n        except grpc.RpcError as e:\n            print(f\"Error reading statistics: {e}\")\n\n    def run(self):\n        \"\"\"Start controller and read statistics\"\"\"\n        self.connect()\n        while True:\n            self.read_forwarding_stats()\n            time.sleep(5)  # Read statistics every 5 seconds\n\n\nif __name__ == \"__main__\":\n    switch_ip = \"192.168.0.1\"  # IP of the P4 switch\n    switch_port = 50051  # P4Runtime port (default 50051)\n    p4info_file = \"build/p4info.txt\"  # Path to P4Info file\n    tofino_json_file = \"build/simple_switch.json\"  # Compiled P4 program file\n\n    controller = P4Controller(switch_ip, switch_port, p4info_file, tofino_json_file)\n    controller.run()"
  },
  {
    "instruction": "Perform 10Mbps traffic shaping on packets received from NIC eth1 on the CPU, set destination IP to 192.168.0.1, and send out from eth1",
    "input": "",
    "output": "#include <stdio.h>\n#include <stdlib.h>\n#include <pcap.h>\n#include <netinet/ip.h>\n#include <netinet/udp.h>\n#include <netinet/tcp.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <net/if.h>\n#include <linux/if_packet.h>\n#include <string.h>\n#include <unistd.h>\n#include <time.h>\n\n#define MAX_PACKET_SIZE 65536\n#define SHAPER_RATE 10000000 // 10 Mbps\n\n// For calculating traffic shaping rate\nunsigned long last_time = 0;\nunsigned long last_bytes = 0;\nunsigned long rate = SHAPER_RATE;\n\n// Process Ethernet packet and modify destination IP\nvoid process_packet(const u_char *packet, int packet_len, struct pcap_pkthdr header, int sockfd) {\n    struct ip *ip_header = (struct ip *)(packet + 14); // IP header after Ethernet header\n    struct sockaddr_ll sa;\n    char new_packet[MAX_PACKET_SIZE];\n    int new_packet_len;\n\n    // Modify destination IP address to 192.168.0.1\n    ip_header->ip_dst.s_addr = inet_addr(\"192.168.0.1\");\n\n    // Copy modified packet to new packet\n    memcpy(new_packet, packet, packet_len);\n    new_packet_len = packet_len;\n\n    // Set socket address\n    memset(&sa, 0, sizeof(struct sockaddr_ll));\n    sa.sll_protocol = htons(ETH_P_IP);  // Set to IP protocol\n    sa.sll_ifindex = if_nametoindex(\"eth1\");  // Use eth1 interface to send\n\n    // Send modified packet\n    sendto(sockfd, new_packet, new_packet_len, 0, (struct sockaddr*)&sa, sizeof(struct sockaddr_ll));\n}\n\n// Get current time (milliseconds)\nunsigned long get_current_time() {\n    struct timespec ts;\n    clock_gettime(CLOCK_MONOTONIC, &ts);\n    return ts.tv_sec * 1000 + ts.tv_nsec / 1000000;\n}\n\n// Calculate whether to wait to ensure 10Mbps rate\nvoid shape_traffic(unsigned long bytes_to_send) {\n    unsigned long current_time = get_current_time();\n    unsigned long elapsed_time = current_time - last_time;\n    unsigned long current_bytes = bytes_to_send;\n\n    if (elapsed_time == 0) {\n        return;\n    }\n\n    // If the number of bytes sent exceeds the expected rate, wait\n    unsigned long expected_bytes = rate * elapsed_time / 1000;  // bytes expected for 1ms\n    if (current_bytes > expected_bytes) {\n        unsigned long wait_time = (current_bytes - expected_bytes) * 1000 / rate;\n        usleep(wait_time);  // Delay wait\n    }\n\n    last_time = current_time;\n    last_bytes = current_bytes;\n}\n\nint main() {\n    pcap_t *handle;\n    struct pcap_pkthdr header;\n    const u_char *packet;\n    char errbuf[PCAP_ERRBUF_SIZE];\n    struct sockaddr_ll sa;\n    int sockfd;\n\n    // Open NIC eth1 for packet capture\n    handle = pcap_open_live(\"eth1\", MAX_PACKET_SIZE, 1, 1000, errbuf);\n    if (handle == NULL) {\n        printf(\"Error opening pcap: %s\\n\", errbuf);\n        return -1;\n    }\n\n    // Create raw socket for sending packets\n    sockfd = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_IP));\n    if (sockfd == -1) {\n        perror(\"Socket creation failed\");\n        return -1;\n    }\n\n    while (1) {\n        packet = pcap_next(handle, &header);\n\n        // Check traffic shaping condition and wait\n        shape_traffic(header.len);\n\n        // Process received packet and modify destination IP\n        process_packet(packet, header.len, header, sockfd);\n    }\n\n    // Close pcap handle and socket\n    pcap_close(handle);\n    close(sockfd);\n\n    return 0;\n}"
  }
]